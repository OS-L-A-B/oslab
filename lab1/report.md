---
title: lab 1：比麻雀更小的麻雀（最小可执行内核）
author: 钱俊玮 朱荟宇 邹博闻
---
# <center>lab 1：比麻雀更小的麻雀（最小可执行内核）</center>

#### <center> 钱俊玮&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;朱荟宇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;邹博闻 </center>
#### <center> 2312480&nbsp;2311824&nbsp;2312251 </center>



### 练习1：理解内核启动中的程序入口操作

在内核启动时，需要完成一系列初始化操作，以建立基本的运行环境。而当OpenSBI刚将CPU的PC指向操作系统内核的入口地址时，操作系统此时处于裸机状态，没有可用的栈空间来保存局部变量或函数调用信息，所以需要预留一块地址区域作为启动栈，用来支持后续的程序运行。

在入口的汇编处，通过`.space`预留了一处地址区域，用bookstack、bookstacktop标识起始和结束位置。

指令
```asm=
la sp, bootstacktop
```
的作用是把栈指针寄存器sp指向启动栈的栈顶地址。这就为后续的程序提供了可用的栈空间。有了空间，就需要执行初始程序。之后的指令
```asm=
tail kern_init
```
会将地址无返回地跳转到kern_init的地址。这个符号在`kern/init/init.c`中被定义，对应操作系统内核的主初始化函数。这句指令的作用是将控制权从汇编启动代码移交给 C 语言实现的内核初始化逻辑，完成内核启动的后续工作。

### 练习2：使用GDB验证启动流程

#### 第一阶段

建立两个终端，左边输入`make debug`启动qemu，给模拟CPU上电；右边输入`make gdb`开启调试。进入调试，显示此时的pc为`0x1000`，正是复位地址。先尝试单步跟踪，在进行了五次运行后发生了跳转，跳转到了`0x80000000`，也就是OpenSBI的代码地址。可以得知最基础的硬件初始化和跳转的步骤就在这几句汇编中。

通过`disassemble /r $pc, $pc+20`反汇编出汇编代码：
```bash
0x0000000000001000:  00000297                auipc   t0,0x0
0x0000000000001004:  02028593                addi    a1,t0,32 # 0x1020
0x0000000000001008:  f1402573                csrr    a0,mhartid
0x000000000000100c:  0182b283                ld      t0,24(t0)
0x0000000000001010:  00028067                jr      t0
```

由代码中可知，初始化步骤首先将pc存进t0中，再将一处特殊地址传给a1寄存器、将当前硬件线程ID传给a0寄存器用于下一个入口，再将\[t0+24\]地址处存的地址传给t0，最后跳转到t0所存的地址。

我们在0x1010处，用`i r`查看此时的寄存器值：
```bash
ra             0x0      0x0
sp             0x0      0x0
gp             0x0      0x0
tp             0x0      0x0
t0             0x80000000       2147483648
t1             0x0      0
t2             0x0      0
fp             0x0      0x0
s1             0x0      0
a0             0x0      0
a1             0x1020   4128
a2             0x0      0
...
```
可以看到，此时t0寄存器存的地址是`0x80000000`，也就是OpenSBI所在地址。后续将由OpenSBI实现开机和加载操作系统到内存中。

#### 第二阶段
SBI固件主初始化主要任务：

将内核加载到 0x80200000

硬件初始化：初始化中断控制器 (PLIC)、定时器 (time CSR)、串口 (UART) 等，为后续调试输出和系统调度打下基础。

提供服务：实现SBI标准，为内核提供通过 ecall 调用的服务接口。

准备内核环境：

生成或加载设备树 (DTB) 到内存中。

将CPU从机器模式 (M-Mode) 切换到监管模式 (S-Mode)。



我们可以从0x80000000开始逐步观察汇编代码
```bash
0x80000000:  csrr    a6,mhartid          //读取硬件线程 ID 到寄存器a6
0x80000004:  bgtz    a6,0x80000108       //如果 a6 > 0（即 Hart ID > 0），跳转到地址 0x80000108
                                         //这是引导处理：Hart 0 执行主初始化，其他 Hart 执行不同的初始化路径

//Hart 0：主初始化
0x80000008:  auipc   t0,0x0
0x8000000c:  addi    t0,t0,1032          //t0 = 0x80000410
0x80000010:  auipc   t1,0x0
0x80000014:  addi    t1,t1,-16           //t1 = 0x80000000，即起始位置
0x80000018:  sd      t1,0(t0)            //将t1的值存入t0指向的地址中，即[0x80000410] = 0x80000000
0x8000001c:  auipc   t0,0x0        
0x80000020:  addi    t0,t0,1020          //t0 = 0x80000418
0x80000024:  ld      t0,0(t0)            //将t0赋值为t0指向的地址的值，即t0 = [0x80000418] = 0x80000000
                                           此后t0的值直到其余Hart验证都不再改变
                                           
0x80000028:  auipc   t1,0x0
0x8000002c:  addi    t1,t1,1016          //将t1赋值为0x80000420
0x80000030:  ld      t1,0(t1)            //t1 = [0x80000420]
0x80000034:  auipc   t2,0x0
0x80000038:  addi    t2,t2,988           //将t2赋值为0x80000410
0x8000003c:  ld      t2,0(t2)            //t2 = [0x80000410] =0x80000000
0x80000040:  sub     t3,t1,t0            
0x80000044:  add     t3,t3,t2            //t3 = t1 - t0 + t2
0x80000046:  beq     t0,t2,0x8000014e    //如果定位正确，则t0 = t2，即t3 = t1，可以正常跳转
                                           否则我们要利用t3的值进行重定位
...

//其余Hart
0x80000108:  auipc   t0,0x0              
0x8000010c:  addi    t0,t0,-264          //t0 = 0x80000000
0x80000110:  auipc   t1,0x0
0x80000114:  addi    t1,t1,776           //t1 = 0x80000418
0x80000118:  ld      t1,0(t1)            //将t1赋值为t1指向的地址的值，即t1 = [0x80000418]
0x8000011c:  beq     t0,t1,0x80000386    //如果 t0 == t1（即 0x80000000 == [0x80000418]），跳转到 0x80000386
                                           这是在检查是否已完成主初始化，如果没有则进行重定位
...

//Hart 0正常跳转
0x8000014e:  auipc   t0,0x0
0x80000152:  addi    t0,t0,698           //t0 = 0x80000408
0x80000156:  li      t1,1                //立即数加载 t1 = 1
0x80000158:  sd      t1,0(t0)            //[0x80000408] = 1，这是在设置同步标志，通知其他核心初始化已完成
0x8000015c:  fence   rw,rw               //内存屏障：确保前面的存储操作对所有核心可见
                                           rw,rw 表示读写-读写屏障，确保屏障前的读写操作在屏障后的操作之前完成
                                           
0x80000160:  li      ra,0                //寄存器清零：ra = 0（返回地址寄存器）为函数调用做准备
0x80000162:  jal     ra,0x80000550       //函数调用：跳转到地址 0x80000550，同时将返回地址 ra = 0x80000166 保存到 ra 寄存器

0x80000166:  add     s0,a0,zero
0x8000016a:  add     s1,a1,zero
0x8000016e:  add     s2,a2,zero
0x80000172:  add     s3,a3,zero
0x80000176:  add     s4,a4,zero          //保存返回值（其实没有返回值）
0x8000017a:  jal     ra,0x80000590
0x8000017e:  add     a0,s0,zero
0x80000182:  add     a1,s1,zero
0x80000186:  add     a2,s2,zero
0x8000018a:  add     a3,s3,zero
0x8000018e:  add     a4,s4,zero          //同上
...

//调用函数
0x80000550:  fence.i                     //指令同步屏障：确保之前的所有指令对后续指令可见
                                           清空指令流水线和缓存，确保后续执行的指令是最新的
0x80000554:  li      sp,0
...                
0x8000058a:  csrwi   mscratch,0          //将各式各样的寄存器清零
0x8000058e:  ret                         //返回
0x80000590:  ret                         //空函数，直接返回
```
这只是SBI主初始化最开始的一段，主要进行了定位检测以及进程同步等操作。之后的代码中还有更多类似于计算帧缓冲区等操作，这里不再一一赘述。

#### 第三阶段
本次实验中，由于qemu版本问题，在跳转执行kern_init环节遇到了较大困难。具体表现为：加电后，程序在第一阶段的末尾（0x1014）有jr t0跳转语句，此时t0内容为0x80000000，这个内容由0x1018位置内容决定。但在跳转后，程序会在0x80000510附近跳转至0x80001320附近，并在此进入一个死循环。由于操作OpenSBI难度较大，故此处没有完整走完kern_init段代码，同时较难把握具体的0x80200000跳转过程，只就0x80200000附近汇编代码情况进行分析。

x/50i 0x80200000后，选择部分较重要的代码分析如下。部分较重要内容以注释形式解释。总体来说，在函数调用前，遵循使用a0~a7寄存器传参，且传参顺序从左向右；调用开始后，遵循抬高
```bash
   0x80200000 <kern_entry>:     auipc   sp,0x3       //此时sp指0x80203000
   0x80200004:                  mv      sp,sp        
   0x80200008:                  j       0x8020000a   //跳init段
   0x8020000a <kern_init>:      auipc   a0,0x3       //a0指向0x8020300a
   0x8020000e:                  addi    a0,a0,-2     //edata地址
   0x80200012:                  auipc   a2,0x3   
   0x80200016:                  addi    a2,a2,-10    //调整为end地址
   0x8020001a:                  addi    sp,sp,-16    //抬高sp，分配16字节空间
   0x8020001c:                  li      a1,0         //a0作为memset第一个参数，a1作为第二个
   0x8020001e:                  sub     a2,a2,a0     //a2参数为end-data
   0x80200020:                  sd      ra,8(sp)     //保存ra
   0x80200022:                  jal     0x80200490   //memset
   0x80200026:                  auipc   a1,0x0       //a1指向pc
   0x8020002a:                  addi    a1,a1,1154   //a1+1154指向THU字符串地址
   0x8020002e:                  auipc   a0,0x0       //准备第一个参数
   0x80200032:                  addi    a0,a0,1178   //第一个参数"%S\n\n"
   0x80200036:                  jal     0x80200054   //cprintf 
   0x8020003a:                  j       0x8020003a   //原地跳转对应while(1)
   0x8020003c:                  addi    sp,sp,-32
   0x8020003e:                  sd      ra,24(sp)
   0x80200040:                  sd      a1,8(sp)
   0x80200042:                  jal     0x80200088
   0x80200046:                  ld      a1,8(sp)
   0x80200048:                  ld      ra,24(sp)
   0x8020004a:                  lw      a5,0(a1)
   0x8020004c:                  addiw   a5,a5,1
   0x8020004e:                  sw      a5,0(a1)
   0x80200050:                  addi    sp,sp,32
   0x80200052:                  ret
   0x80200054 <cprintf>:        addi    sp,sp,-96    //抬高栈空间
   0x80200056:                  addi    t1,sp,40     //后续都是调用cprintf的操作
   0x8020005a:                  sd      a1,40(sp)
   0x8020005c:                  sd      a2,48(sp)
   0x8020005e:                  sd      a3,56(sp)
   ...
 
```